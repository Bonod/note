1. 计算结构体成员的偏移量
```c
#define offsetof(TYPE,MEMBER)   (size_t) &((TYPE *)0)->MEMBER)
```
2. 计算字节中`bit`为`1`的数量
``` c
int Count(BYTE v)
{
    int num = 0;
    while (v)
    {
        v &= (v - 1); //v=v&(v-1)这个操作可以直接消除掉v中的最右边的1。
        num++;
    }
    return num;
}
```
3. 将字节中`1`分量分离并打印
```c
void print_one_bit(uint16 v)
{
    uint16 prev = 0;
    prev = v;
    while (v)
    {
        v &= (v - 1);
        printf("0x%04x\n", v ^ prev);
        prev = v;
    }
}
```
4. 判断大小端
- 大端，数据的高字节保存在内存的低地址处，数据的低字节保存在内存的高地址处
- 小端，数据的高字节保存在内存的高地址处，数据的低字节保存在内存的低地址处
``` c++
#include <iostream>
using namespace std;
int main()
{
    int a = 1;
    if (*(char*)&a == 1)
        cout << "小端模式" << endl;
    else
        cout << "大端模式" << endl;
    return 0;
}
```
5. 快速判断掩码第一个为1的Bit位置
``` c
int GetUnUseMem(U32 UseMask)  
{  
	register U32 index = UseMask ;  
	//将第一个为1位的低位都置1，其它位都置0  
	index = (index-1) & ~index;//得到有多少为1的位index = index&0x55555555 + (index>>1)&0x55555555;  
	index = index&0x33333333+ (index>>2)&0x33333333;  
	index = index&0x0F0F0F0F+ (index>>4)&0x0F0F0F0F;  
	index = index&0xFF + (index&0xFF00 >> 8) + (index&0xFF0000 >> 16) + (index&0xFF000000 >> 24);  
	//得到位数,如果为32则表示全0  
	return (int)(index);  
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1MTY1MTMwMDAsLTIwNTg2Mjk4NzYsMT
k1OTM4MDI3OSwtMTc4NzkyODU3MCwtMTQzMDgxODE2N119
-->