# 第5章 运输层
- 重要概念
	1. 运输层为相互通信的应用进程提供**逻辑通信**。
	2. 端口和套接字的意义。
	3. **无连接**的UDP的意义。
	4. **面向连接**的TCP的特点。
	5. **在不可靠的网络上实现可靠传输**的工作原理，**停止等待协议**和**ARQ协议**。
	6. TCP的**滑动窗口**、**流量控制**、**拥塞控制**和**连接管理**。
## 5.1 运输层协议概述
### 5.1.1 进程之间的通信
- 只有**主机**的协议栈才有运输层，而网络核心部分中的**路由器**在转发分组时都只用到下三层的功能
- 从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。**端到端的通信是应用进程之间的通信**
- **复用**（multiplexing）和**分用**（demultiplexing）
- **网络层**为**主机**之间提供逻辑通信，而**运输层**为**应用进程**之间提供端到端的逻辑通信
- 运输层还要对收到的报文进行**差错检查**
- 运输层需要有两种不同的运输协议
	- **面向连接的TCP**，一个全双工的可靠信道
	- **无连接的UDP**，一条不可靠信道
### 5.1.2 运输层的两个主要协议
- TCP/IP运输层的两个主要协议都是互联网的正式标准
	- **用户数据报协议 UDP（User Dategram Protocol）[RFC 768]**
	- **传输控制协议 TCP（Transmission Control Protocol）[RFC 793]**
<table>
    <tr>
        <td colspan="2" align="center">应用层</td>
    </tr>
    <tr>
        <td>UDP</td>
        <td>TCP</td>
    </tr>
    <tr>
        <td colspan="2" align="center">IP</td>
    </tr>
    <tr>
        <td colspan="2" align="center">与各种网络接口</td>
    </tr>
</table>

- TCP/IP体系中的**运输协议数据单元 TPDU（Transport Protocol Data Unit）**
	- **TCP报文段（segment）**
	- **UDP用户数据报**
- UDP在传送数据之前**不需要先建立连接**。远地主机的运输层在收到UDP报文后，不需要给出任何确认（不可靠但是效率高）
- TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务（可靠且面向连接但开销大）
- 使用UDP和TCP协议的各种应用和应用层协议

| 应用 | 应用层协议 | 运输层协议 |
|--|--|--|
| 名字转换 | DNS（域名系统） | UDP |
| 文件传送 | TFTP（简单文件传送协议） | UDP |
| 路由选择协议 | RIP（路由信息协议） | UDP |
| IP地址配置 | DHCP（动态主机配置协议） | UDP |
| 网络管理 | SNMP（简单网络管理协议） | UDP |
| IP电话 | 专用协议 | UDP |
| 流式多媒体通信 | 专用协议 | UDP |
| 多播 | IGMP（网际组管理协议） | UDP |
| 电子邮件 | SMTP（简单邮件传送协议） | TCP |
| 远程终端接入 | TELNET（远程终端协议） | TCP |
| 万维网 | HTTP（超文本传送协议） | TCP |
| 文件传送 | FTP（文件传送协议） | TCP |
### 5.1.3 运输层的端口
- **协议端口号（protocol port number）**，简称为**端口（port）**
- TCP/IP的运输层用一个16位**端口号**来标志一个端口
- 运输层的端口号
	- **服务器使用的端口号**，是固定的
		- **熟知端口号（well-known port number）**或**系统端口号**，数值为**0~1023**
		- **登记端口号**， 数值为**1024~49151**
	- **客户端使用的端口号**，存在时间是短期的
		- **短暂端口号**，数值为**49152~65535**

| 应用程序 | 熟知端口号 |
|--|--|
| FTP | 21 |
| TELNET | 23 |
| SMTP | 25 |
| DNS | 53 |
| TFTP | 69 |
| HTTP | 80 |
| SNMP | 161 |
| SNMP（trap） | 162 |
| https | 443 |
## 5.2 UDP概述
- UDP的主要特点
	- UDP是**无连接**的
	- UDP使用**尽最大努力交付**，即不保证可靠交付
	- UDP是**面向报文**的，**保留应用层交下来的报文的边界**
	- **UDP没有拥塞控制**
	- **UDP支持一对一、一对多、多对一和多对多的交互通信**
	- **UDP的首部开销小**，只有8个字节
### 5.2.2 UDP的首部格式
- UDP的首部
	- **首部字段**，每个字段的长度都是两个字节
		- **源端口**
		- **目的端口**
		- **长度** 
			- **其最小值是8（仅有首部）**
		- **校验和**
	- **数据字段**
- 接受方UDP发现收到的报文中的**目的端口号不正确**，就丢弃该报文，并由**ICMP**发送**“端口不可到达”差错报文**给发送方
- UDP不需要套接字
- 12字节伪首部
	- **源IP地址**，**4**字节
	- **目的IP地址**，**4**字节
	- **IP首部中的协议字段**，**1**字节，对于UDP，此协议字段值为**17**
	- **全零字段**，**1**字节
	- **UDP用户数据报长度**，**2**字节
- UDP的检验和是把**伪首部**、**首部**和**数据部分**一起都检验
	- 发送方
		1. 先将检验和字段置零
		2. 再用全零字节填充报文至偶数个字节
		3. 然后按二进制反码计算16位字的和
		4. 将计算结果取反得到检验和
	- 接收方
		1. 先用全零字节填充报文至偶数个字节
		2. 然后按二进制反码计算16位字的和
		3. **当无差错时其结果应为全1**
## 5.3 传输控制协议TCP概述
### 5.3.1 TCP最主要的特点
1. TCP是**面向连接的运输层协议**
2. 每一条TCP连接只能有两个**端点（endpoint）**
3. TCP提供**可靠交付**的服务
4. TCP提供**全双工通信**
5. **面向字节流**
### 5.3.2 TCP的连接
- TCP连接的端点叫做**套接字（socket）**或**插口**
- **端口号**拼接到（concatenated with）**IP地址**即构成了套接字
$$套接字socket = (IP地址:端口号)$$
- 每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定
$$TCP连接::=\{socket_1,socket_2\}=\{(IP_1:port_1),(IP_2:port_2)\}$$
- 同一个名词socket却可表示多种不同的意思
	1. socket API
	2. 在socket API中使用的一个函数名也叫做socket
	3. 调用socket函数的端点称为socket
	4. 调用socket函数时，其返回值称为socket描述符，可简称为socket
	5. 在操作系统内核中联网协议的Berkeley实现，称为socket实现
	6. **RFC 793定义的socket**
## 5.4 可靠传输的工作原理
- 理想的传输条件
	1. 传输信道不产生差错
	2. 不管发送方以多快的速度发送数据，接受方总是来得及处理收到的数据
### 5.4.1 停止等待协议
- 无差错情况
- 出现差错
- 确认丢失和确认迟到
- 信道利用率
$$U=\frac{T_D}{T_D+RTT+T_A}$$
### 5.4.2 连续ARQ协议
- 积累确认
### 5.5 TCP报文段的首部格式
- TCP报文段首部长度为20+4n
- 首部固定部分字段

| 字段 | 大小 | 意义 |
|--|--|--|
| 源端口 | 2 byte |  |
| 目的端口 | 2 byte |  |
| 序号 | 4 byte |  |
| 确认号 | 4 byte | 是期望收到对方下一个报文段的第一个数据字节的序号 |
| 数据偏移 | 4 bit | TCP报文段的首部长度，单位为32位字 |
| 保留 | 6 bit |  |
| 紧急URG（URGent） | 1 bit | 当URG=1时，表明紧急指针字段有效 |
| 确认ACK（ACKnowledgment） | 1 bit | 仅当ACK=1时，确认号字段才有效 |
| 推送PSH（PuSH） | 1 bit | 接受方TCP收到PSH=1的报文段，就尽快交付接受应用进程 |
| 复位RST（ReSet） | 1 bit | 当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后在重新建立运输连接。RST置1还用来拒绝一个非法报文段或者拒绝打开一个连接 |
| 同步SYN（SYNchronization） | 1 bit | SYN置为1就表示这是一个连接请求或连接接受报文 |
| 终止FIN（FINis） | 1 bit | 当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接 |
| 窗口 | 2 byte | 窗口指的是发送本报文段的一方的接受窗口 |
| 检验和 | 2 byte | 检验字段的范围包括首部和数据这两部分 |
| 紧急指针 | 2 byte | 紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。即使窗口为零时也可发送紧急数据 |
| 选项 | 0~40 byte | 最大报文段长度MSS（Maximum Segment Size）、窗口扩大选项、时间戳选项 |
## 5.6 TCP可靠传输的实现
### 5.6.1 以字节为单位的滑动窗口
### 5.6.2 超时重传时间的选择
- **报文段的往返时间RTT**
- **加权平均往返时间RTT$_s$**
$$新的RTT_s=(1-\alpha)\times(旧的RTT_s)+\alpha\times(新的RTT样本)$$
	- RFC 6298推荐的$\alpha$值为0.125
- **超时重传时间RTO（RetransmissionTime-Out）**
$$RTO=RTT_S+4\times RTT_D$$
- 
## 5.8 TCP的拥塞控制
### 5.8.1 拥塞控制的一般原理
- **拥塞（congestion）**
- 在计算机网络中的**链路容量（即带宽）**、交换结点中的**缓存**和**交换机**等，都是网络的资源
- 出现网络拥塞的条件
$$\sum 对资源的需求>可用资源$$
- **所谓拥塞控制就是防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载**
- 拥塞控制的前提
	- **网络能够承受现有的网络负荷**
- 拥塞控制是一个**全局性**的过程
- **流量控制往往是指点对点通信量的控制**，是个**端到端**的问题
- 拥塞控制
	- 开环控制
	- 闭环控制
### 5.8.2 TCP的拥塞控制方法
- TCP进行拥塞控制的算法有四种
	- **慢开始（slow-start）**
	- **拥塞避免（congestion）**
	- **快重传（fast restransmit）**
	- **快恢复（fast recovery）**
- **慢开始门限**
- **3-ACK**
- 发送方的窗口的上限值
$$发送方窗口的上限值=Min[rwnd, cwnd]$$
### 5.8.3 主动队列管理AQM
- **尾部丢弃策略（tail-drop policy）**（网络层）
- **全局同步（global syncronization）**
- **主动队列管理AQM（Active Queue Management）**
	- **随机早期检查RED（Random Early Detection）**
		1. 若**平均队列长度**小于**最小门限**，则把新到达的分组放入队列进行排队
		2. **若平均队列长度**超过**最大门限**，则把新到达的分组放弃
		3. **若平均队列长度**在**最小门限**和**最大门限**之间，则按照某一个**丢弃概率p**把新到达的分组丢弃
> **RFC 7567**不再推荐使用**RED**
## 5.9 TCP的运输连接管理
- 运输连接三个阶段
	- 连接建立
	- 数据传送
	- 连接释放
- TCP连接建立过程中要解决以下三个问题
	- 要使每一方能够确知对方的存在
	- 要允许双方协商一些参数
	- 能够对运输实体资源进行分配
- TCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做**客户（client）**，而被动等待连接建立的应用进程叫做**服务器（server）**
### 5.9.1 TCP的连接建立
- **传输控制块TCB（Transmission Control Block）**
- 三次握手
TODO 插入图片
	1. A向B发出连接请求报文端，**SYN=1**，**seq=x**。TCP客户进程进入**SYN-SENT（同步已发送）状态**
	2. B收到A的连接请求报文段后，如果同意建立连接，则向A发送报文段，**SYN=1**，**ACK=1**，**ack=x+1**，**seq=y**。B从**LISTEN状态**进入**SYN-RCVD（同步收到）状态**
	3. A收到B的报文段后，还要向B给出确认报文段，**ACK=1**，**ack=y+1**，**seq=x+1**。A进入**ESTABLISHED（已建立连接）状态**
- 第一次握手的SYN报文段和第二次握手的报文段**不能携带数据**，**但要消耗一个序号**，而第三次握手的ACK报文段**可以携带数据**，但如果**不携带数据则不消耗序号**，此时下一个数据报文段的序号仍是seq=x+1
- 第二次握手的报文段可以拆分成两个报文段。可以先发送一个**确认报文段**（ACK=1，ack=x+1），然后再发送一个**同步报文段**（SYN=1，seq=y）
### 5.9.2 TCP的连接释放
- 四次挥手
TODO 放图
	1. A向B发送连接释放报文段，**FIN=1**，**seq=u**（它等于上一个已传送的报文段的seq加1）。此时A从**ESTABLISHED（已建立连接）状态**进入**FIN-WAIT-1（终止等待1）状态**
	2. B收到A的连接释放报文段后即发出确认报文段，**ACK=1**，**ack=u+1**，**seq=v**（等于上一个已传送的报文段的seq加1）。此时B从**ESTABLISHED（已建立连接）状态**进入**CLOSE-WAIT（关闭等待）状态**；A收到B的确认报文段后，就进入**FIN-WAIT-2（终止等待2）状态**，等待B发出的连接释放报文段
	3. 若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。此时B向A发送连接释放报文段，**FIN=1**，**ack=u+1**，**seq=w**（等于上一个已传送的报文段的seq加1，半关闭状态B可能又发送了一些数据），此时B进入**LAST-ACK（最后确认）状态**
	4. A收到B的连接释放报文段向B发送确认报文段，**ACK=1**，**ack=w+1**，**seq=u+1**，此时A进入**TIME-WAIT（最后确认）状态**。经过**时间等待计时器（TIME-WAIT timer）**设置的时间**2MSL**后，A才进入**CLOSED状态**；B接受的A的确认报文段后就进入**CLOSED状态**
- TCP计时器
	- **重传计时器(Retransmission Timer)**
	-  **持续计时器(Persistent Timer)**
	- **时间等待计时器（TIME-WAIT timer）**
	- **保活计时器（Keepalive timer）**
### 5.9.3 TCP的有限状态机
TODO 放图
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2OTQ0MzY5NzcsLTIxMTUwNDg5ODYsOT
g0Mzg2ODAyLDY2MjY3NTkzNCwxNDg1ODU1ODQ2LDEwMDE0ODM5
NDgsMTE2NzkzMjAzNiwtNzE5OTQwNzc3LC0xMzY2ODM2ODEwLD
IxNDIwMzI2NjksMTM2MTEwMTE5Myw3MDU4Mjg3MzksNzk2MjQ3
OTM3LC0xOTIwOTE5ODE3LC00ODI4MDEwNjAsMjAyMzU5NDM2Ni
wtMzc2ODc1MzIsNTQxNjkwOTUwLC0yNzQ1ODY3MTMsOTk1MDkx
NTgzXX0=
-->