# 第四章 对象和类
## 4.1 面向对象程序设计概述
- **OOP** 把数据结构放第一位，算法放第二位
### 4.1.1 类
- 概念
	- 类 **class**
	- 构造 **construct**
	- 实例 **instance**
	- 封装 **encapsulation**
	- 实例域 **instance field**
	- 方法 **method**
	- 状态 **state**
	- 继承 **inheritance**
### 4.1.2 对象
- 特性
	- 行为 **behavior**
	- 状态 **state**
	- 标示 **indentity**
- 对象状态改变必须通过调用方法实现，否则说明封装性遭到破坏
### 4.1.3 标识类
### 4.1.4 类之间的关系
- 最常见的关系
	- 依赖  **dependence**， **user-a**
	- 聚合 **aggregation**， **has-a**
	- 继承 **inheritance**， **is-a**
- **UML** ( **Unified Modeling Language**，统一建模语言)
## 4.2 使用预定义类
### 4.2.1 对象与对象变量
- 构造器应与类同名
- 一个对象变量未实际包含一个对象，仅是引用一个对象
- 可以显示地将对象变量设置为 **null**
- **局部变量**不会自动地初始化为 **null**，必须通过 **new**或者设置为 **null** 进行初始化
### 4.2.2 **Java** 类库中的 **LocalDate** 类
- 纪元 **epoch**，**UTC** 时间1970年1月1日00:00:00
### 4.2.3 更改器方法与访问器方法
- 更改器方法 **mutator method**
- 访问器方法 **accessor method**
## 4.3 用户自定义类
### 4.3.1 **Employee** 类
- 最简单的类定义形式
``` java
class ClassName {
	field 1
	field 2
	...
	constructor 1
	constructor 2
	...
	method 1
	method 2
	...
}
```
- 一个源文件只能有一个共有类，可以有无数非共有类
### 4.3.2 多个源文件的使用
### 4.3.3 剖析 **Employee** 类
- 有四种访问级别
- 不提倡使用 **public** 标记实例域
### 4.3.4 从构造器开始
- 不能对一个已经存在的对象调用构造器来达到重置实例域的目的，这将引起编译错误
- 构造器重点
	- 构造器与类同名
	- 每个类可以有一个以上的构造器
	- 构造器可以有任意多个参数
	- 构造器无返回值
	- 构造器总伴随这 **new** 操作一起调用
- 不要在构造器中定义与实例域同名的局部变量
### 4.3.5 隐式参数与显式参数
- 关键字 **this** 为隐式参数
### 4.3.6 封装的优点
- 推荐：
	- 一个私有的数据域
	- 一个公有的域访问器方法
	- 一个公有的域更改器方法
- 不要编写直接返回引用可变对象的访问器方法。当需要返回一个可变对象的引用时，应先对其进行克隆( **clone** )，在返回这个对象副本
### 4.3.7 基于类的访问权限
### 4.3.8 私有方法
### 4.3.9 **final** 实例域
- 建议只应用**final** 修饰符于基本( **primitive** )类型域或不可变( **immutable** )类的域
## 4.4 静态域与静态方法
### 4.4.1 静态域
- 静态域只属于类，不属于任何独立的对象
### 4.4.2 静态常量
### 4.4.3 静态方法
- 静态方法是一种不能对对象实施操作的方法
- 静态方法没有 **this** 参数，只能访问自身类的静态域
- 使用静态方法的场景
	- 一个方法不需要访问对象状态，其参数都是显式参数
	- 一个方法只需要访问类的静态域
### 4.4.4 工厂方法
### 4.4.5 **main** 方法
## 4.5 方法参数
- 相关术语
	- 按值调用 **call by value**
	- 按引用调用 **call by reference**
- **Java** 总是按值调用
-  对象引用是按值传递
- 总结
	- 一个方法不能修改一个基本数据类型的参数
	- 一个方法可以修改一个对象参数的状态
	- 一个方法不能让对象参数引用一个新的对象
## 4.6 对象构造
### 4.6.1 重载
- **Java** 允许重载任何方法
- 返回类型不是方法的签名( **signature** )的一部分
### 4.6.2 默认域初始化
- 实例域会被自动赋予默认值
### 4.6.3 无参数的构造器
- 如果没有编写类的构造器，系统会提供一个无参数的构造器
- 如果编写了类的构造器，但是没有编写无参数的构造器，则系统不会提供无参数的构造器
### 4.6.4 显式域初始化
- 可以调用方法对域进行显式初始化
### 4.6.5 参数名
### 4.6.6 调用另一个构造器
- 使用 **this(...)** 可以在一个构造器中调用同一个类的另一个构造器
### 4.6.7 初始化块
- 初始化数据域的方法
	- 在构造器中赋值
	- 在声明中赋值
	- 初始化块 **initialization**
- 初始化数据域顺序
	- 数据域被初始化为默认值
	- 按类声明中的顺序依次执va行域初始化语句和初始化块
	- 执行构造器
``` java
// static initialization block
static {
	program statements
}
```
### 4.6.8 对象析构与 **finalize** 方法
- **Java** 不支持析构器
- **Java** 的 **GC** 只负责内存相关的清理
- **GC** 在清除对象前会自动调用其 **finalize** 方法
- 不建议依赖 **finalize** 回收短缺资源
- **finalize** 抛出的未捕获异常只会导致该对象的 **finalize** 执行退出
- 可以手动调用 **finalize**
## 4.7  包
### 4.7.1 类的导入
- **Java** 的 **package** 与 **import** 语句类似于 **C++** 的 **namespace** 和 **using** 指令
### 4.7.2 静态导入
- 导入静态方法和静态域：
``` java
import static ...
```
### 4.7.3 将类放入包中
### 4.7.4 包作用域
- 未指定 **public** 或 **private** 的类、方法或变量可被同一个包中的所有方法访问
## 4.8 类路径
- 类路径必须与包名匹配
### 4.8.1 设置类路径
``` shell
# unix
java -classpath /home/user/classdir:.:/home/user/archives/archive.jar HyProg
# windows
java -classpath /home/user/classdir;.;/home/user/archives/archive.jar HyProg
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTUxODE5Njk4LC0xMjE1OTg0NzAwLC0yMT
A3MzM1MTU1LDEzNzAxOTkxNTcsMTgxNzk3MTg4Nyw4ODY0NTk1
MDYsLTE5MTc3NTk1MDUsNjQ3MjU3MTg2LC00NjY5ODE0OTYsMT
A4OTk3NTU0MywtMTU4NzU5MTUxMywtNTE5OTY4MjMyLC04NDY5
NjgzNDYsLTIwMzE0NDU5OSwtMTg1OTE2OTAzOSwxNDEwODAxOT
Y1LC02MjAwMTgzMTQsLTExMDMyNTY3OTAsMTUzNTYzNzczMSwt
MjEwMDMxNzkwMV19
-->