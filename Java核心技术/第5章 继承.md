# 第5章 继承
## 5.1 类、超类和子类
### 5.1.1 定义子类
- **extends**
### 5.1.2 覆盖方法
- 重写 **override**
- 子类无法访问超类私有域
- 使用关键字 **super** 以调用超类方法
``` java
super.method(...)
```
- 子类无法删除超类任何域和方法
### 5.1.3 子类构造器
- 若子类构造器未显式调用超类构造器，则将自动调用超类默认的无参数构造器
- 关键字 **super**
	- 调用超类方法
	- 调用超类构造( 该语句只能在一个构造器的第一条语句出现 )
- 多态 **plymorphism** 
	-	一个对象变量可以指示多种实际类型的现象
- 动态绑定 **dynamic binding**
	- 在运行时可以自动地调用哪个方法的现象
- 如果不希望一个方法具有虚拟特征，可以将它标记为 **final**
### 5.1.4 继承层次
- **Java** 不支持多继承
### 5.1.5 多态
- “ **is a** ” 规则
- 里氏替换原则_
- 不能将超类的引用赋给子类变量
- 在**Java** 中，子类数组的引用可以转换成超类数组的引用。
> 让一个子类数组变量与一个超类数组变量引用同一个子类数组是合法的。此时如果试图通超类数组变量向数组存储一个超类引用，虽然能编译通过，但是运行时会引发 **ArrayStoreException** 异常
### 5.1.6 理解方法调用
- 返回类型不是签名的一部分
	- 覆盖方法时要保证返回类型的兼容性
	- 运行子类将覆盖方法的返回类型定义为原返回类型的子类型
- 静态绑定 **static binding**
	- **private** 方法
	- **static** 方法
	- **final** 方法
	- 构造器
- 动态绑定 **dynamic binding**
	- 方法表 **method table**
- 动态绑定的好处
	- 无需对现存代码修改编译
- 覆盖一个方法时，子类方法不能低于超类方法可见性
### 5.1.7 阻止继承：**final** 类和方法

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwMzQwMzM1MTEsMTk0NjQ0OTU5MSwxOT
M3NzE2MjAsMTU2NjE5MjUyOCwtNjk2MjY2MDc2LC0xODIyMTE0
NDYxLC02NjQzNDAwMDAsLTg5NDczNTI1NCwtMTI1NzQzMjc3OS
wtNDkwMzM5OTc1LC0zNDE3NTc3ODYsLTE0MTIxNjQyMzksLTQ1
MTU5MTM0OCwxNjgzNDkyMDk3LDIwNzE4MDEyNTcsNDkyMDE3Mj
NdfQ==
-->